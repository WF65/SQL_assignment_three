-- part 1

--1
/*
It depends. If the subqueries are not correlated subqueries, then it is okay to use either join or subquery.
However, if it needs to use correlated subqueries, in this case, it is more reasonable to use correlated
subqueries. Beacause correlated subqueries are faster and more easy to use and understand.
*/

--2
/*
CTE is common table expressions.
It can be used to:
- create a recursive query
- substitute for a view when the general use of a view is not required, that is, user does not need to 
  store the definition in metadata.
- using a CTE offers the advantage of improved readability and ease in maintenance of complex quries.
  The query can be divided into seperate, simple. logical building blocks. These simple blocks can then 
  be used to build more complex, interim CTEs until the final result set is generated.
- CTE can be defined in user-defined routines, such as functions, stored procedures, triggers, or views.
*/

--3
/*
A table variable is a data type that can be used within a Transact-SQL batch, stored procedure, or function,
and is created and defined similiarly to a table only with a strictly defined lifetime scope.
The lifttime of the table variables only last for the duration of the batch, function, or stored procedure.
And the storage for the table variable is in the tempdb system database.
*/

--4
/*
Differences between DELETE and TRUNCATE:
- TRUNCATE reseeds identity values, whereas DELETE does not.
- TRUNCATE removes all records and does not fire trigger.
- TRUNCATE is not possible when a table is referenced by a foreign key or tables are used in replication
  or with indexed views.

TRUNCATE is faster compared to delete as it makes less use of the transaction log.
*/

--5
/*
An identity column is a column in a database table that is made up of values generated by the database.

When the DELETE statement is executed without WHERE clause it will delete all the rows. When a new record 
is inserted, the identity value keeps on increasing from the deleted records instead of reset.

When the TRUNCATE statement is executed, it will remove all the rows. However, when a new record is inserted,
the identity value is resetted to the original seed value of the table.
*/

--6
/*
Without where cluase in DELETE statement, both DELETE statement and TRUNCATE statement will delete
all the records in the table.

DELETE statment deletes rows one at a time, logging each row in the transaction log, as well as maintaing
log sequence number information. Although this consumes more database resources and locks, these transactions
can be rolled back if necessary. And when delete a large number of rows using DELETE statment, the table may
hang on to the empty pages requiring manual release using DBCC SHRINKDATABASE (db_name).

TRUNCATE table is a statement that quickly deletes all records in a table by deallocating the data pages
used by the table. This reduces the resource overhead of logging the deletions, as well as the number of 
locks required. However, it bypasses the transaction log, and the only record of the transaction in the 
transaction log is the page deallocation. Records removed by the TRUNCATE statement cannot be restored. 
And it does not allow a WHERE clause in the statment, it is all or nothing. The advantage of using TRUNCATE 
statement is that in addtion to removing all rows from the table, it resets the IDENTITY back to the seed,
and the deallocated pages are returned to the system for use in other areas.
In addtion, it cannt be used for tables involved in replication or log shipping, since both depend on 
transaction log to keep remote database consistent.
Also, TRUNCATE statement cannot be used when a foreign key reference the table to be truncated since
it do not fire triggers. This could result in inconsistent data because ON DELETE/UPDATE trigger would
not fire.
*/

--part 2

--1
--select c.City --, count(c.CustomerID) as CustomerCount, count(e.EmployeeID) as EmployeeCount 
--from Customers c inner join Employees e
--on c.City = e.City
--group by c.City
--having count(c.CustomerID) > 0 and count(e.EmployeeID)>0
--order by c.City

select distinct c.City
from Customers c
where c.City in
(select distinct e.City from Employees e)

--2
--(1)
--select c.City --, count(c.CustomerID)
--from Customers c
--where c.City not in 
--(select e.City
--from Employees e 
--group by e.City
--having count(e.EmployeeID) > 0
--)
--group by c.City
--having count(c.CustomerID) > 0
--order by c.City

select distinct c.City
from Customers c
where c.City not in
(select distinct e.City from Employees e)

--(2)
select distinct c.City
from Customers c left join Employees e
on c.City = e.City
where e.EmployeeID is null

--3
select p.ProductName, sum(d.Quantity) as TotalSoldQuantity
from Products p left join [Order Details] d
on p.ProductID = d.ProductID
group by p.ProductName

--4
select c.City, sum(d.Quantity) as TotalQuantity
from Customers c left join Orders o
on c.CustomerID = o.CustomerID
left join [Order Details] d
on o.OrderID = d.OrderID
group by c.City

--5
--confused about this question, not sure what to do
--(a)
select c.city
from Customers c 
group by c.City 
having count(c.CustomerID)>2 

union

select c.city
from Customers c 
group by c.City 
having count(c.CustomerID)=2 

--(b)
select distinct City
from Customers
where City in
(select c.city as "City"
from Customers c 
group by c.City 
having count(c.CustomerID)>=2 
) 

--6
select dt.ShipCity
from
(select distinct o.ShipCity, d.ProductID
from Orders o inner join [Order Details] d
on o.OrderID = d.OrderID)dt
group by dt.ShipCity
having count(dt.ProductID) >= 2

--7
select distinct c.ContactName
from Customers c inner join
(
select distinct o.CustomerID, o.ShipCity
from Orders o
)dt
on c.CustomerID = dt.CustomerID
where c.City != dt.ShipCity

--8
-- use dense_rank
with cteProductSoldCount
as
(
	select top 5 p.ProductName, p.ProductID, sum(d.Quantity) as TotalSoldQuantity, 
	sum((d.UnitPrice - d.Discount)*d.Quantity) as TotalSoldPrice
	from Products p inner join [Order Details] d
	on p.ProductID = d.ProductID
	group by p.ProductName, p.ProductID
	order by TotalSoldQuantity
), cteSoldByCity
as
(
	select d.ProductID, o.ShipCity, sum(d.Quantity) as "SoldByCity",
	DENSE_RANK() over(PARTITION by d.ProductID
	order by d.ProductID, sum(d.Quantity) desc) as "OrderByCity"
	from Orders o inner join [Order Details] d
	on o.OrderID = d.OrderID
	group by d.ProductID, o.ShipCity
	--order by d.ProductID, OrderByCity
)
select pc.ProductName, (pc.TotalSoldPrice/pc.TotalSoldQuantity) as "AveragePrice",
sc.ShipCity as "CityOrderedMost"
from cteProductSoldCount pc left join cteSoldByCity sc
on pc.ProductID = sc.ProductID
where sc.OrderByCity <= 1

-- use  row_number
with cteProductSoldCount
as
(
	select top 5 p.ProductName, p.ProductID, sum(d.Quantity) as TotalSoldQuantity, 
	sum((d.UnitPrice - d.Discount)*d.Quantity) as TotalSoldPrice
	from Products p inner join [Order Details] d
	on p.ProductID = d.ProductID
	group by p.ProductName, p.ProductID
	order by TotalSoldQuantity
), cteSoldByCity
as
(
	select d.ProductID, o.ShipCity, sum(d.Quantity) as "SoldByCity",
	ROW_NUMBER() over(PARTITION by d.ProductID
	order by d.ProductID, sum(d.Quantity) desc) as "OrderByCity"
	from Orders o inner join [Order Details] d
	on o.OrderID = d.OrderID
	group by d.ProductID, o.ShipCity
	--order by d.ProductID, OrderByCity
)
select pc.ProductName, (pc.TotalSoldPrice/pc.TotalSoldQuantity) as "AveragePrice",
sc.ShipCity as "CityOrderedMost"
from cteProductSoldCount pc left join cteSoldByCity sc
on pc.ProductID = sc.ProductID
where sc.OrderByCity <= 1

--9
--(a)
select distinct e.City
from Employees e 
where e.City not in
(
	select distinct o.ShipCity
	from Orders o
)

--(b)
select distinct e.City
from Employees e
except
select distinct o.ShipCity
from Orders o

--10
select top 1 dr1.City, dr1.SoldByCity, dr2.TotalOrders
from
(
select o.ShipCity as "City", sum(d.Quantity) as "SoldByCity"
from Orders o inner join [Order Details] d
on o.OrderID = d.OrderID
group by o.ShipCity
)dr1
inner join
(
select e.City as "City", count(o.OrderID) as "TotalOrders"
from Employees e inner join Orders o
on e.EmployeeID = o.EmployeeID
group by e.City
)dr2
on dr1.City = dr2.City
order by dr1.SoldByCity, dr2.TotalOrders

--11
--using cte, suppose the table Employees{ID, FirstName, LastName, Country}

-- to find the duplicated row, the code could be like below, and if any row has the row
--number greater than 1 then it is duplicate row

--use dense_rank
with cte
as
(
	select ID, FirstName, LastName, Country,
	DENSE_RANK() over (partition by FirstName, LastName, Country order by ID) 
	as "DuplicateCount"
	from Employees
)
select ID, FirstName, LastName, Country, DuplicateCount
from cte

--use row_number
with cte
as
(
	select ID, FirstName, LastName, Country,
	ROW_NUMBER() over (partition by FirstName, LastName, Country order by ID) 
	as "DuplicateCount"
	from Employees
)
select ID, FirstName, LastName, Country, DuplicateCount
from Employees

--the following code could be used to remove duplicate rows

--use dense_rank
with cte
as
(
	select FirstName, LastName, Country,
	DENSE_RANK() over (partition by FirstName, LastName, Country order by ID) 
	as "DuplicateCount"
	from Employees
)
delete from cte
where DuplicateCount > 1

--use row_number
with cte
as
(
	select FirstName, LastName, Country,
	ROW_NUMBER() over (partition by FirstName, LastName, Country order by ID) 
	as "DuplicateCount"
	from Employees
)
delete from cte
where DuplicateCount > 1

--12
select e.empid
from Employee e
where e.empid not in
(
	select distinct m.mgrid
	from employee m
)

--13
with cteEmployeeNumber
as 
(
	select d.deptid, count(e.empid) as "EmployeeNumber"
	from employee e inner join dept d
	on e.deptid = d.deptid
	group by d.depid
), cteMaxEmployeeNumber
as
(
	select max(en.EmployeeNumber) as "MaxNumber"
	from cteEmployeeNumber en
)
select en.deptid
from cteEmployeeNumber en
where en.EmployeeNumber = cteMaxEmployeeNumber.MaxNumber
order by en.deptid

--14
with cteSalary
as
(
	select d.deptname, d.deptid, e.empid, e.salary
	from employee e inner join dept d
	on e.deptid = d.deptid
), cteSalaryOrder
as
(
	select s.deptname, s.deptid, s.empid, s.salary
	ROW_NUMBER() over(partition by s.deptid, s.empid, e.salary, 
	order by s.deptid, s.empid, s.salary) as "orders"
	from cteSalary s
)
select o.deptname, s.empid,s.salary
from cteSalaryOrder o
where o.orders <=3
order by o.deptname, s.empid,s.salary





